# Checklist

- 인터넷은 어떻게 동작하나요? OSI 7 Layer에 입각하여 설명해 보세요.
- 우리가 브라우저의 주소 창에 [www.knowre.com](http://www.knowre.com/) 을 쳤을 때, 어떤 과정을 통해 노리의 서버 주소를 알게 되나요?

# Quest

- tracert(Windows가 아닌 경우 traceroute) 명령을 통해 [www.google.com](http://www.google.com/) 까지 가는 경로를 찾아 보세요.
    - 어떤 IP주소들이 있나요?
    - 그 IP주소들은 어디에 위치해 있나요?
- Wireshark를 통해 [www.google.com](http://www.google.com/) 으로 요청을 날렸을 떄 어떤 TCP 패킷이 오가는지 확인해 보세요
    - TCP 패킷을 주고받는 과정은 어떻게 되나요?
    - 각각의 패킷에 어떤 정보들이 담겨 있나요?
- telnet 명령을 통해 [http://www.google.com/](http://www.google.com/) URL에 HTTP 요청을 날려 보세요.
    - 어떤 헤더들이 있나요?
    - 그 헤더들은 어떤 역할을 하나요?

# Answers

> 인터넷은 어떻게 동작하나요? OSI 7 Layer에 입각하여 설명해 보세요.


### Physical Layer (물리 계층)

먼저 **물리계층**에 해당하는 허브를 통해 `플로딩(Flooding)` 작업을 해줘야 합니다. 이는 브로드캐스트의 성질과 유사한데, 어떤 PC의 데이터가 허브로 보내졌다면, 허브에서는 허브에 포함된 모든 PC들에게 모두 데이터를 보내줍니다. 이는 빠른 송신을 위해서인데, 허브에서 목적지에 대한 조사나 원하는 곳으로만 데이터를 전달하게 되면 허브의 작업비용은 매우 높습니다.

전달받은 PC에서는자신에게 온 데이터라면 이를 받아들이고, 아니면 그냥 무시합니다.

또한 물리 계층에서는 물리적 전기 신호가 목적지까지 안전하게 갈 수 있도록 `리피터(Repeater)` 역할도 수행하게 됩니다. 이 리피터도 역시 플로딩 작업을 통해 작동하기 때문에 하나의 리피터에 연결된 모든 장비는 같은 데이터를 듣게 됩니다.

전송 단위 - bit

대표 장치 - Hub

### Data Link Layer (데이터 링크 계층)

물리 계층(허브)에서 전기 신호를 플로딩으로 전송하였고, 수신자 측에서는  자신의 데이터가 맞다면 해당 데이터를 받아들일지 말지 판단해야 합니다. 이 판단을 수행하는 계층이 바로 **데이터 링크 계층**입니다. 물리 계층에서는 신호의 내용을 전혀 확인하지 않습니다. 하지만 데이터 링크에서는 앞서 온 신호를 Frame으로 변환할 수 있습니다.

이 Frame 에는 `MAC Address` 라는 고유한 주소가 존재합니다. 이 주소는 무조건 유일해야 합니다. 컴퓨터를 사거나 서버를 구매하게 되는 일이 생기면 공유 네트워크 카드가 존재합니다. 이 네트워크 카드가 가지고 있는 물리적 주소가 바로 `MAC Address` 입니다.

데이터 링크 계층에서는 `MAC Address`를 통해 주소 할당을 해주어야 합니다. 물리 계층에서 온 신호를 우리가 원하는 `MAC Address` 에 제대로 전달 해 줄 수 있어야 데이터 링크 계층의 역할을 한 것입니다. 이 기능을 수행하는 대표적인 장치가 `스위치(Switch)` 입니다.

또한 데이터 링크 계층은 물리 계층에서 발생한 오류를 감지할 수 있어야 합니다. 물리 계층에서는 신호 내용에 대한 체크를 하지 않으므로, 신호 증폭에 실패하여 데이터를 받지 못하게 된다해도 이를 알 방법이 없습니다. 그렇기에 물리 계층에서 데이터의 오류가 발생한다면 이를 데이터 링크 계층에서 알아차리고 `MAC Address` 에 써있는 주소에게 말해 데이터를 다시 보내라고 요청해야 합니다.

전송 단위 - Frame

대표 장치 - L2 Switch, 브릿지

프로토콜 - 이더넷, MAC, PPP, LAN, WiFi

### Network Layer (네트워크 계층)

이더넷을 통해 인터넷에 들어온 곳이 출발점 이라면, 목적지 네트워크까지 어떤 노드를 거쳐 어떻게 도달할지 정해야 합니다. 이 흐름 제어 역할을 하는 장비가 바로 `라우터(Router)` 입니다. 이 라우터에 도달한 정보들을 라우터가 정해주는 방향으로 움직이게 됩니다.

라우터가 하는 라우팅을 위해 모든 네트워크 접속자는 주소를 가지고 있어야 합니다. 이 주소가 바로 `IP Address` 입니다.

**네트워크 계층**에서 수행하는 작업들은 다음과 같습니다.

- 라우팅 : 라우팅 테이블을 통해 Packet의 다음 경로를 어디로 할지 정해주는 작업
- 포워딩 : 라우팅 작업을 통해 결정 된 경로로 데이터를 Packet구조로 만들어 다음 라우터로 Packet으로 전달하는 작업

네트워크 계층에서는 데이터 링크 계층에서 받은 Frame을 Packet으로 관리합니다. 데이터 링크 계층에서 MAC을 보고 데이터를 전달하고 수신 받았다면, 다음 라우팅의 목적지를 위한 MAC주소가 중요합니다. 여기서 새로운 Packet을 만들어 내야 하는데, Frame을 Packet으로 나누고 IP주소를 확인합니다. 라우터의 라우팅 테이블은 IP주소에 따라 어떤 MAC주소를 부여해야 할 지가 정의 되어 있습니다. 이렇게 만들어진 새로운 Packet을 네트워크 가드애 전해주는 것이 네트워크 계층의역할 입니다.

전송 단위 - Packet

대표 장치 - Router

프로토콜 : IP, ICMP 등

### Transport Layer (전송 계층)

**전송 계층**의 주 목적은  양 끝에 있는 두 사용자간에 데이터를 정확하게 전달할 수 있는가? 입니다.

네트워크 계층에서 전송한 Packet이 IP주소를 통해 원하는 네트워크에 도달 했다면, Packet에서 IP부분을 제외한 Segment의 적합성을 봐야 합니다. 즉, 전송 계층에서의 데이터 단위는 '세그먼트(Segment)' 입니다.

과거의 송신은 '회선 교환' 방식이였습니다. 이 방식에서는 굳이 전송 계층이 필요하지 않았습니다. 왜냐하면 회선 교환 방식에서는 데이터 전송을 원하는 두 지점의 회선 경로가 미리 정해진 방식이였고, 데이터가 중간에 바뀔 염려는 없었습니다. 하지만 해당 회선(경로)에 문제가 생기면 데이터를 주고받지 못하는 문제가 생겼습니다.

현대의 송신은 '패킷 교환' 으로 전부 바뀌었습니다. 경로가 정해지지 않은채로 데이터를 전송하면 네트워크 환경 안에서 임의의 경로에 따라 움직이게 되었습니다. 일부 회선이 손상 되더라도 데이터가 송신된다는 장점은 있었지만, Packet의 정확성이 문제였습니다. 이러한 문제를 해결하기 위해 생겨난 프로토콜이 **TCP(Transport Control Protocol)**와 **UDP(User Datagram Protocol)**입니다.

TCP는 `Three Way Handshake` 로 이를 정의합니다.

1. 내가 통신을 원하는 대상에게 통신을 원한다는 메세지를 보낸다. (SYN)
2. SYN을 받은 대상이 통신 준비가 되었다는 정보를 송신자에게 보낸다. (SYN-ACK)
3. SYN-ACK 를 잘 받았다고 다시 한번 수신자에게 확인을 한다. (ACK)

이렇게 두 네트워크가 연결이 되었다면 데이터를 서로 주고 받으며 정확성이 보장된 데이터를 주고 받게 됩니다. 이러한 정확성 보장은 TCP의 가장 큰 특징이기도 합니다. TCP에서는 내가 보낸 데이터가 얼마나 전송 되었고, 어느 부분이 누락 되었는지 까지 판단해 양자간의 정확한 전송이 보장됩니다.

반면에 UDP는 조금 다릅니다. UDP는 신뢰성 보다는 **신속함**에 초점이 맞춰져 있습니다. 앞서 설명한 과정 다 필요없이 그냥 IP주소보고 데이터를 마구잡이로 보내는 과정입니다. 이는 굉장히 쓸모없어 보이지만 미디어 전송에서 빛을 발합니다. 헤더의 길이가 TCP에 비해 월등히 짧기 때문에(UDP 헤더 : 목적지 주소와 실데이터) 데이터 누락이 발생 되었는지 눈치도 못 챌 정도로 잘 보여주게 됩니다.

전송 단위 - Segment(세그먼트)

대표 장치 - L4 Switch, 게이트웨이

프로토콜 - TCP, UDP, ARP

### Session Layer (세션 계층)

앞서 전송 계층을 통해 두 네트워크간의 연결이 성립되었다면, 우리는 이를 네트워크 세션이 생성되었다고 표현합니다. 만약 TCP로 연결이 성립되면 TCP세션이라고 합니다. 형성된 세션간의 데이터 송수신을 어떻게 관리 할지에 대해 정의해야 하는데 이것이 **세션 계층에서의 역할**입니다. 한번 연결된 세션에서 향후 표현 계층과 응용 계층에서 어떻게 사용자에게 정보를 보여줄 것인지, 형성된 세션이 끊기지 않도록 어떻게 관리할 것인지 정의하는 것이 세션 계층의 역할입니다.

세션 계층에서는 TCP/IP 세션을 만들고 없애는 책임을 집니다. 통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룹니다.

세션 계층의 역할은 아래와 같습니다.

- 세션 설정 및 해제 방법 정의 (인증 및 허가도 포함)
- 세션 다중화  / 단일화 : 통신 효율을 위해 세션을 다중화 할지 단일화 할지 결정
- 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex) 결정
- 세션 회복

운영체제 실습을 해본적이 있는 사람이라면, 리눅스를 사용할 때 원격 접속을 위해 SSH를 사용하게 되는데, SSH가 세션계층에서 작동하는 대표적인 프로토콜입니다.

전송 단위 - Data

대표 장치 - L5 Switch

프로토콜 - NetBIOS, SSH, TLS

### Presentation Layer (표현 계층)

**표현 계층**에서는 전달 받은 네트워크 메시지를 사용자가 볼 수 있도록 만드는 기능을 합니다. 지금까지 누군가가 보낸 메시지를 Frame, Packet, Segment로 포장해서 전달했다면, 이 포장지를 뜯어서 사용자에게 전달하는 기능이 표현 계층의 역할입니다.

표현 계층에서 진행하는 3가지 기능은 아래와 같습니다.

- 수신자 장치(노트북, 스마트폰 등)에 적합한 어플리케이션으로 노출 시킬 수 있도록 데이터를 해석
- 수신자에서 압축을 풀 수 있는 방식으로 된 데이터 압축
- 데이터 암호화 / 복호화

표현 계층에서는 우리가 응용 계층에서 메시지를 볼 수 있도록 진행하는 사전 작업이자, 네트워크 환경으로 데이터를 넘기기 위해 진행하는 사전 작업으로 볼 수 있습니다. 대표적으로 `MIME(Multipurpose Internet Mail Extensions)` 가 표현 계층에서 작동합니다.

프로토콜 - JPG, MPEG, SMB

### Application Layer (응용 계층)

**응용 계층**은 우리에게 친숙합니다. 네트워크 기능을 작동하는 모든 프로그램들은 응용 계층에서 작동합니다. 우리가 쓰고 있는 크롬, 사파리 등 웹 브라우저는 물론이고, 인터넷에 글을 올리는 행위, 멀티 게임을 하기 위해 접속하는 행위 모든 것이 응용 계층입니다. 간단히 표현하면, 우리가 네트워크로 접속하기 위한 사용자 인터페이스를 의미합니다.

응용 계층에는 많은 프로토콜이 존재합니다. 아래는 대표적인 응용 계층의 프로토콜 입니다.

- 텔넷(TELNET) : 원격지의 호스트 컴퓨터에 접속하기 위해 사용하는 인터넷 프로토콜
- DNS(Domain Name System) : 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 반대의 변환을 수행하는 프로토콜
- FTP(File Transfer Protocol) : 서버/클라이언트 사이의 파일 전송을 위한 프로토콜
- HTTP(Hyper Text Transfer Protocol) : WWW 상에서 정보를 주고받을 수 있는 프로토콜, HTML 문서를 주고 받는 역할 등
- SMTP(Simple Mail Transfer Protocol) : 인터넷에서 이메일을 보내기 위해 사용하는 프로토콜

## 인터넷 동작 원리?

### Physical Layer

각 PC는 연결될 준비가 되어야 합니다. 각 컴퓨터의 허브에 포트를 연결합니다. 허브에 연결된 포트는 Flooding 작업을 통하여 신호가 들어온 포트를 제외한 모든 포트에 신호를 전달합니다.

### Data Link Layer

허브를 통해 들어온 신호를 프레임으로 필터링하고, MAC Address를 이용하여 데이터를 보내고자 하는 포트에만 신호를 전달합니다.

### Network Layer

허브, 스위치를 이용하여 LAN을 구성한 후에 외부와 연결하기 위해서는 라우터가 필요합니다. 라우터는 라우팅이라는 과정을 통해 한 네트워크에서 다른 네트워크로 패킷을 전달하기 위해 사용합니다. Network Layer에서는 IP주소를 사용해서 전달합니다.

### Transport Layer

네트워크 계층에서 전송한 패킷이 IP주소를 통해 원하는 네트워크에 도달했다면, 패킷에서 IP 부분을 제외하고 Segment의 적합성을 봅니다. TCP프로토콜 - 3 Way Hand Shake를 통해 서로간 연결을 확인하고, 데이터를 주고받을 준비를 합니다.

### Session Layer

위에서 TCP로 연결이 되었으니 TCP 세션이 생성됩니다. 세션 계층에선 한번 연결된 세션에서 향후 표현 계층과 응용 계층에서 어떻게 사용자에게 정보를 보여줄 것인지, 형성된 세션이 끊기지 않도록 어떻게 관리할 것인지 정의합니다.

### Presentation Layer

표현 계층에서는 위 계층에서 전달받은 데이터를 사용자에게 전달해야 합니다. 수신자 장치에 맟게 데이터를 해석하고 압축합니다.

### Application Layer

이제 사용자에게 보여줄 일만 남았습니다. 브라우저, 모바일 앱 등 사용자에게 닿는 모든 행위는 응용 계층입니다.

---

> 우리가 브라우저의 주소 창에 [www.knowre.com](http://www.knowre.com/) 을 쳤을 때, 어떤 과정을 통해 노리의 서버 주소를 알게 되나요?

1. PC 브라우저에서 [www.knowre.com](http://www.knowre.com) 을 입력합니다.
2. PC는 미리 설정되어 있는 DNS(Local DNS)에게 "www.knowre.com"이라는 hostname에 대한 IP주소를 물어봅니다.
3. Local DNS에는 "www.knowre.com"에 대한 캐싱되어 있지 않다고 가정하겠습니다.
4. Local DNS는 "www.knowre.com"에 대한 IP주소를 찾아내기 위해 다른 DNS 서버들과 통신(DNS Message)을 시작합니다. 먼저 Root DNS 서버에게 "www.knowre.com"에 대한 IP주소를 아는지에 대해 질의합니다.
5. Local DNS가 Root DNS에 질의하기 위해  각 Local DNS 서버에는 Root DNS 서버의 정보 (IP Address)가 미리 설정되어 있어야 합니다.
6. Root DNS 서버는 "www.knowre.com"에 대해 모릅니다. 그래서 .com 도메인이기 때문에 Local DNS 서버에게 com Domain을 관리하는(TLD) DNS서버의 정보를 포함하여 응답합니다.
7. Local DNS 서버는 "com Domain"을 관리하는 DNS 서버에게 "www.knowre.com"에 대한 IP 주소를 아는지에 대해 질의합니다.
8. "com Domain"을 관리하는 DNS 서버또한 해당 정보가 없습니다. 그래서 Local DNS 서버에게 "knowre.com" 도메인을 관리하는 DNS서버의 정보를 포함하여 응답합니다.
9. Local DNS 서버는 "knowre.com" 도메인을 관리하는 DNS 서버에게 "www.knowre.com"에 대한 IP주소를 질의합니다.
10. 이 DNS 서버는 [knowre.com](http://knowre.com) 도메인을 직접 매니징하고 있으므로 해당 IP 주소를 반환할 수 있게 됩니다.
11. 이를 수신한 Local DNS는 [www.knowre.com](http://www.knowre.com) 에 대한 IP주소를 캐싱하고 단말(PC)에 전달해 줍니다.

이와 같이 Local DNS 서버가 여러 DNS 서버를 차례대로 (Root DNS → com DNS → [knowre.com](http://knowre.com) DNS)물어봐서 그 답을 **Recursive Query**라고 부릅니다.

---

> tracert(Windows가 아닌 경우 traceroute) 명령을 통해 [www.google.com](http://www.google.com/) 까지 가는 경로를 찾아 보세요.

- 어떤 IP주소들이 있나요?
- 그 IP주소들은 어디에 위치해 있나요?

```
// 공유기 IP
1  
192.168.219.1 (192.168.219.1)  3.218 ms  1.777 ms  2.123 ms

// LG POWERCOM - 서울
2  
49.171.95.129 (49.171.95.129)  7.447 ms  7.054 ms  8.508 ms

// Fail
3  
10.203.29.129 (10.203.29.129)  4.308 ms  4.998 ms  5.740 ms

// LG DACOM - 용산
4  
1.213.20.205 (1.213.20.205)  4.592 ms
1.208.20.221 (1.208.20.221)  3.657 ms   
1.213.20.1 (1.213.20.1)  3.395 ms

// LG DACOM - 용산
5  
1.208.167.133 (1.208.167.133)  7.940 ms
1.213.152.177 (1.213.152.177)  4.923 ms
1.208.167.133 (1.208.167.133)  7.280 ms

// LG DACOM - 용산
6  
1.213.107.253 (1.213.107.253)  4.250 ms
61.42.202.129 (61.42.202.129)  4.493 ms
1.208.145.18 (1.208.145.18)  5.799 ms

// LG DACOM - 용산
7  
1.208.167.105 (1.208.167.105)  3.886 ms
1.208.174.29 (1.208.174.29)  4.912 ms
1.208.145.189 (1.208.145.189)  4.835 ms

// LG DACOM - 용산
8  
1.208.0.74 (1.208.0.74)  50.289 ms
164.124.250.202 (164.124.250.202)  49.542 ms
203.252.13.22 (203.252.13.22)  39.177 ms

// LG DACOM - 용산
9  
1.208.106.106 (1.208.106.106)  40.203 ms
1.208.150.182 (1.208.150.182)  38.743 ms
1.208.148.206 (1.208.148.206)  46.546 ms

// Google LLC - United States
10  
74.125.118.154 (74.125.118.154)  47.885 ms
72.14.215.29 (72.14.215.29)  50.765 ms
74.125.118.154 (74.125.118.154)  40.901 ms

// Fail
11  * 10.252.54.126 (10.252.54.126)  56.955 ms *

// Google LLC - Canada
12  
108.170.241.33 (108.170.241.33)  41.817 ms
108.170.241.97 (108.170.241.97)  52.353 ms
72.14.234.62 (72.14.234.62)  49.768 ms

// Google LLC - Canada
13  
108.170.241.79 (108.170.241.79)  43.670 ms
108.170.241.48 (108.170.241.48)  57.734 ms
108.170.241.112 (108.170.241.112)  39.848 ms

// Google LLC - United States
14  
216.239.62.165 (216.239.62.165)  49.609 ms
216.239.63.216 (216.239.63.216)  49.412 ms
209.85.142.203 (209.85.142.203)  40.273 ms

// Google LLC - Canada
15
* 209.85.245.161 (209.85.245.161)  64.221 ms
172.253.50.221 (172.253.50.221)  54.761 ms

// Google LLC - Canada
16  
209.85.251.170 (209.85.251.170)  55.561 ms
209.85.247.118 (209.85.247.118)  54.278 ms
209.85.249.144 (209.85.249.144)  63.387 ms

// Google LLC - Canada
17  
216.239.50.243 (216.239.50.243)  53.268 ms
74.125.252.231 (74.125.252.231)  56.760 ms
216.239.50.243 (216.239.50.243)  54.880 ms

18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *

// Google LLC - Taiwan
27  tg-in-f106.1e100.net (74.125.23.106)  60.099 ms  51.111 ms  51.437 ms
```

---

> Wireshark를 통해 [www.google.com](http://www.google.com/) 으로 요청을 날렸을 떄 어떤 TCP 패킷이 오가는지 확인해 보세요
- TCP 패킷을 주고받는 과정은 어떻게 되나요?
- 각각의 패킷에 어떤 정보들이 담겨 있나요?

![img.png](img.png)

- 먼저 `3-Way Hand Shake` 과정을 수행합니다.
    - Client(Source Port) 에서 Server(Destination Port)로 통신을 원한다는 신호를 보냅니다. [SYN] Seq = 0
    - Server에서 SYN을 정상적으로 받았다는 신호를 보냅니다. [SYN, ACK] Seq=0 Ack=1
    - Client에서 SYN-ACK를 잘 받았다고 신호를 보냅니다. [ACK] Seq=1 Ack=1
- Client 에서 HTTP 요청을 보냅니다. [GET / HTTP/1.1]
- Server 측에서 확인 신호를 보냅니다.

### TCP 패킷 정보
![img_1.png](img_1.png)

- Source Port (발신지 포트 필드) : 발신지 포트 필드는 발신지에서 오픈된 포트입니다. 위 포트를 보면 50572 포트인 것을 확인할 수 있습니다.
- Destination Port (목적지 포트 필드) : 목적지 포트 필드는 수신지에서 오픈된 포트입니다. 위의 패킷을 보면 51462 포트인 것을 확인할 수 있습니다.
- Squence Number (순차 번호 필드) : 순차번호필드는 고유한 번호를 가지며, 이 값으로 TCP 세그먼트에 대한 식별값을 제공하며, 통신 스트림일부가 분실되면 확인을 위해 수신자를 사용가능하게 합니다. 이 순차번호는 패킷에 포함되어 있는 데이터 만큼 증가하게 됩니다.
- Acknowledgement Number (확인 응답 번호 필드) : 확인 응답 번호 필드는 다음번에 기대되는 순차번호를 표시합니다. ack number에 관련하여 530의 값을 가지게 됩니다.
- Header Length (데이터 오프셋 필드) : 데이터 오프셋필드는 TCP헤더의 길이를 정의합니다. 길이는 4byte씩 증가되고, 이 필드의 값이 20이면 80바이트 길이를 갖는다는 것입니다.

---

> telnet 명령을 통해 [http://www.google.com/](http://www.google.com/) URL에 HTTP 요청을 날려 보세요.
- 어떤 헤더들이 있나요?
- 그 헤더들은 어떤 역할을 하나요?

```
Trying 108.177.97.103...
Connected to www.google.com.
Escape character is '^]'.
GET / HTTP/1.1

HTTP/1.1 200 OK
Date: Thu, 04 Feb 2021 05:34:47 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
P3P: CP="This is not a P3P policy! See g.co/p3phelp for more info."
Server: gws
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN
Set-Cookie: 1P_JAR=2021-02-04-05; expires=Sat, 06-Mar-2021 05:34:47 GMT; path=/; domain=.google.com; Secure
Set-Cookie: NID=208=gX8nt2mkFX74bpfjWdJO2Go_oz6GRdJkhGzSoLtANLrmF16RAXMrLt0ER8F1ZHJnQjLXms-Y26-CDURg3rMHgfPPQtxSRaKxY01olVECwPE5TPajzYVGQvvdwqofOdATZtfPNlG2AOdc-wDvZ5iKl_FyOdeskzGr_Es6nv0-Wg0; expires=Fri, 06-Aug-2021 05:34:47 GMT; path=/; domain=.google.com; HttpOnly
Accept-Ranges: none
Vary: Accept-Encoding
Transfer-Encoding: chunked
```

### 헤더의 역할

- Date : HTTP 메세지 생성 일자
- Connection : Server / Clinet 간의 연결 옵션
- Cache-Control : 쿠키/캐시 관련 정보
- Content - Type : 미디어 타입 정보
- Expires : 리소스가 지정된 일시까지 유효함을 나타냄.
- Server : 서버의 정보
- X-XSS-Protection  : 특정 브라우저에서 제공하는 기능, XSS공격을 감지 할 때 페이지 로드를 중지 시킬 수 있음
- X-Frame-Options : 해당 페이지를 `<frame>` 또는 `<iframe>` , `<object>` 에서 렌더링 할 수 있는지 여부를 나타내는데 사용 됨
- Set-Cookie : 서버측에서 클라이언트측으로부터 세션 쿠기 정보를 설정 함
- Accept-Ranges : 부분 요청에 지원을 알리기 위해 서버에 의해 사용되는 표식. 이 헤더가 존재하면 브라우저는 처음부터 다시 다운로드를 시작하지 않고, 중단된 다운롣를 재개하려고 함.
- Vary : 캐시 된 응답을 향후 요청들에서 오리진 서버로 새로운 요청 헤더를 요청하는 대신 사용할 수 있는지 여부를 결정함.
- Tranfer-Encoding : 사용자에게 entitiy를 안전하게 전송하기 위해 사용하는 인코딩 형식을 지정함.